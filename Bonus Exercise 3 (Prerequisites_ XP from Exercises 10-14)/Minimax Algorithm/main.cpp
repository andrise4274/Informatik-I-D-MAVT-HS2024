#include <iostream>
#include <climits>
#include "node.h"
#include "tree_creator.h"



// ------------------------ generated by Chat GPT -----------------------------------
// in one prompt and 2 reprompts
// ----------------------------------------------------------------------------------



// Minimax function
int minimax(Node* position, bool colour) {
    if (!position) {
        // If the node is null (due to pruning), return an invalid value
        return 0;
    }

    if (!position->left && !position->right) {
        // Leaf node: return its value
        return position->value;
    }

    if (colour) {
        // Anna (Purple) maximizes her score
        int leftValue = position->left ? minimax(position->left, false) : INT_MIN;
        int rightValue = position->right ? minimax(position->right, false) : INT_MIN;
        return std::max(leftValue, rightValue);
    } else {
        // Raphi (Black) minimizes Anna's score
        int leftValue = position->left ? minimax(position->left, true) : INT_MAX;
        int rightValue = position->right ? minimax(position->right, true) : INT_MAX;
        return std::min(leftValue, rightValue);
    }
}

// Alpha-Beta Pruning function
int alpha_beta_pruning(Node* position, int alpha, int beta, bool colour) {
    if (!position) {
        // If the node is null, return a neutral value
        return 0;
    }

    if (!position->left && !position->right) {
        // Leaf node: return its value
        return position->value;
    }

    if (colour) {
        // Anna (Purple) maximizes her score
        int leftValue = alpha_beta_pruning(position->left, alpha, beta, false);
        alpha = std::max(alpha, leftValue);

        if (beta <= alpha) {
            // Prune the right subtree
            delete position->right; // Free memory for the pruned subtree
            position->right = nullptr;
            return alpha;
        }

        int rightValue = alpha_beta_pruning(position->right, alpha, beta, false);
        return std::max(leftValue, rightValue);
    } else {
        // Raphi (Black) minimizes Anna's score
        int leftValue = alpha_beta_pruning(position->left, alpha, beta, true);
        beta = std::min(beta, leftValue);

        if (beta <= alpha) {
            // Prune the right subtree
            delete position->right; // Free memory for the pruned subtree
            position->right = nullptr;
            return beta;
        }

        int rightValue = alpha_beta_pruning(position->right, alpha, beta, true);
        return std::min(leftValue, rightValue);
    }
}

// Main function
int main() {
    Node* root;

    bool success = create_tree(std::cin, root);
    if (!success) {
        std::cout << "Error: Could not create the tree." << '\n';
        return 1;
    }

    std::cout << "\n>> " << minimax(root, true) << " <<\n";
    alpha_beta_pruning(root, INT_MIN, INT_MAX, true);
    print_tree(root);
    std::cout << "\n>> " << minimax(root, true) << " <<\n";

    // Release all the allocated memory
    delete root;

    return 0;
}
